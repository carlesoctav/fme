please see ./data/masked_langauge_modeling.py and next_token_prediction.py
and here's the spec that you need to implement (modify)

first, 
about packing,
we'll try to pack the seq of data (potetinally small data) into one giant data with seq_length = seq_length.
if we use packing, we'll use seq_len bin_size,
and by default use local_batch_size as the num of bin,
(set higher num of bin to minimize padding token (increase num of bin means we've more chance to pack a random sequence with random length))
we'll get another column called segment_ids that tell each token original data.
i think we also get position_ids (but you need to verify this first)

  """Creates a 'packed' version of a dataset on-the-fly.
  Adapted from the mesh-tf implementation.
  This is meant to replace the irritation of having to create a separate
  "packed" version of a dataset to train efficiently on TPU.
  Each example in the output dataset represents several examples in the
  input dataset.
  For each key in the input dataset, two additional keys are created:
  <key>_segmentation: an int32 tensor identifying the parts
     representing the original example.
  <key>_position: an int32 tensor identifying the position within the original
     example.
  Example:
  Two input examples get combined to form an output example.
  The input examples are:
  {"inputs": [8, 7, 1, 0], "targets":[4, 1, 0]}
  {"inputs": [2, 3, 4, 1], "targets":[5, 6, 1]}
  The output example is:
  {
                 "inputs": [8, 7, 1, 2, 3, 4, 1, 0, 0, 0]
    "inputs_segmentation": [1, 1, 1, 2, 2, 2, 2, 0, 0, 0]
        "inputs_position": [0, 1, 2, 0, 1, 2, 3, 0, 0, 0]
                "targets": [4, 1, 5, 6, 1, 0, 0, 0, 0, 0]
   "targets_segmentation": [1, 1, 2, 2, 2, 0, 0, 0, 0, 0]
       "targets_position": [0, 1, 0, 1, 2, 0, 0, 0, 0, 0]
  }
  0 represents padding in both the inputs and the outputs.
  Sequences in the incoming examples are truncated to length "length", and the
  sequences in the output examples all have fixed (padded) length "length".


since we need to infer attention_mask based on this segmentation, please add segment_ids inside my bert, and on the
src/attention please create a util function to create this attention_mask based on this segment_ids, see ~/personal/maxtext how to this.




------- attention design ------------------


AttentionModule(eqx.Module)
    config: AttentionConfig | None = field(static = True)


    def __init__(store_config = True)


class SDPA(AttentionModule):

    def create_mask():
        
    def __call__():
        do things




with attention(AttentionModule, AttentionConfig, *args, **kwargs):
    bert = BertModel() (basicly swap the AttentionModule/backend) 


the thing is  we need this contextmanager when we pas this into setup_module_opts()
how can i achieve that.

with attention(AttentionModule, AttentionConfig):
    bert = setup_module_opts() is ok?


and how this on let say abstractmodule something like

with attention(AttentionModule, AttentionConfig, *args, **kwargs):
    bert = eqx.filter_eva_shape(BertModel, *args, **kwargs) 
